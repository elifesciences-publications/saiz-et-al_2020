# This script takes in the raw output generated by ablat_read.R
# and performs transformations on the data, namely:
# * correcting for fluorescence decay along the Z-axis

# Check if setup.R has been ran
setup.ran <- exists('looks')
if (setup.ran == F) { 
  source('./src/setup.R')
}
rm(setup.ran)

# Check if data is already loaded 
data.exsts <- exists('ablat')
if(data.exsts == F) { 
  ablat <- read.csv('./data/raw/ablat-fixed-raw.csv')
  ablat.t0 <- read.csv('./data/raw/ablat-t0-raw.csv')
  ablat.ref <- read.csv('./references/ablat_exp_ref.csv')
}
rm(data.exsts)

# Load functions that will be used in the script
source('./src/functions/eb_cor.R')
source('./src/functions/tx_channels.R')

# Load Immunofluorescence reference file and incorporate into data
ablat.if <- read.csv('./references/ablat_if.csv')
ablat <- merge(ablat, ablat.if)

# Modify the Experiment variable to account for genotypes
ablat$Experiment <- paste(ablat$Experiment, ablat$Treatment, 
                          ablat$Gene1, ablat$Genotype1, sep = '.')

# Extract marker info for each experiment
unicos <- ablat %>% filter(Channel %in% c('CH2', 'CH3', 'CH5')) %>% 
  group_by(Experiment, Treatment, Genotype1, Channel, Marker) %>% 
  summarize()
unicos <- dcast(unicos, Experiment + Treatment + Genotype1 ~ 
                         Channel, value.var = 'Marker')

# Write out unicos table to disk
write.csv(unicos, file = './references/ablat_unicos.csv')

# Pluck out only Channel 2 information, necessary to group embryos
# for fluorescence correction below
ablat.ch2 <- unicos %>% select(Experiment, Treatment, Genotype1, CH2)
ablat.ch2 <- rename(ablat.ch2, CH2.marker = CH2)
ablat <- merge(ablat, ablat.ch2)
rm(ablat.ch2)

################################################################################
## Order factors as desired
################################################################################

# Order factors in fixed dataset
ablat$TE_ICM <- factor(ablat$TE_ICM, levels = c('TE', 'ICM'))
ablat$Genotype1 <- factor(ablat$Genotype1, levels = c('wt', 'het'))
ablat$Genotype2 <- factor(ablat$Genotype2, 
                          levels = c('wt', 'mKate/+', 'mKate/mKate'))
ablat$Genotype3 <- factor(ablat$Genotype3, 
                          levels = c('wt', 'het'))
ablat$Stage.t0 <- factor(ablat$Stage.t0, 
                         levels = c('[30,50)', '[50,70)', '[70,90)', 
                                    '[90,110)', '[110,130)', '[130,150)', 
                                    '[150,170)', '[170,190)', '[190,210]'))

# Make Treatment a factor
ablat$Treatment <- factor(ablat$Treatment, levels = c('Littermate', 'Control', 
                                                      'Ablated', 'Random'))
# Make Cell_diff a factor and order levels
ablat$Cell_diff <- factor(ablat$Cell_diff, 
                          levels = c('zero', 'kill_0.25', 'kill_0.5', 
                                     'kill_0.75', 'kill_all'))

# Make litter a factor 
ablat$Litter <- factor(ablat$Litter)

# Order Stage.t0 for live dataset also
ablat.t0$Stage.t0 <- factor(ablat.t0$Stage.t0, 
                            levels = c('[30,50)', '[50,70)', '[70,90)', 
                                       '[90,110)', '[110,130)', '[130,150)', 
                                       '[150,170)', '[170,190)', '[190,210]'))

################################################################################
# Write out a table with N numbers for each experimental group -
# combination of lineage targeted, % of cells targeted and Stage.t0
################################################################################

n.embryos <- ablat %>% filter(interaction(Channel, Marker) != 'CH2.no.ab', 
                              Recovery %in% c('24h', '0min'),  
                              Exp_date > 20170601) %>% 
  group_by(Embryo_ID, Treatment, target, Stage.t0, Cell_diff) %>% 
  summarize() %>%
  group_by(Stage.t0, Treatment, target, Cell_diff) %>% 
  summarize(N = n())
n.embryos <- dcast(n.embryos, target + Stage.t0 + Cell_diff ~ Treatment, 
                   value.var = 'N')
n.embryos[is.na(n.embryos)] <- '--'
# and write it out as a .csv file
write.csv(n.embryos, file = './results/ablat_N-embryos.csv', row.names = F)

################################################################################
## Correct for fluorescence decay along the Z-axis
################################################################################

#### In fixed data:

# Define the possible channels to go through
channels <- c('CH1.Avg', 'CH2.Avg', 'CH3.Avg', 'CH5.Avg')
# Create an empty matrix to hold the corrected values
# with the length of the number of cells in the dataset
ebLogCor <- matrix(0, nrow = length(ablat$Embryo_ID), 
                   # and as many columns as channels
                   ncol = length(channels),
                   dimnames = list(c(), channels))
# For each channel in 'channels', perform EB correction 
# and store in the corresponding column in 'ebLogCor'
# Critically, use the marker for CH2 as grouping variable for ebcor()
# (see annotation in eb_cor.R for details)
for (c in channels) {
  ebLogCor[, c] <- ebcor(ablat, c, group = ablat$CH2.marker)
}
# Convert ebLogCor to data frame and rename columns to CHX.ebLogCor
ebLogCor <- data.frame(ebLogCor)
ebLogCor <- rename(ebLogCor, CH1.ebLogCor = CH1.Avg, 
                   CH2.ebLogCor = CH2.Avg, 
                   CH3.ebLogCor = CH3.Avg,
                   CH5.ebLogCor = CH5.Avg)

# Incorporate ebLogCor values into main table
ablat <- cbind(ablat, ebLogCor)
rm(ebLogCor)

#### In live data, for CH1 only (Pdgfra:H2B-GFP)

# Apply eb.cor() to live data
ablat.t0$CH1.ebLogCor <- ebcor(ablat.t0, 1)

# Some embryos are mKate2/+ or mKate2/mKate2, which signal is in CH2,
# however, we are not analyizing those values for the time being, 
# so there is no correction applied to CH2

################################################################################
# Transform fluorescence values obtained with NANOG.rat and GATA6.rb to
# NANOG.rb and GATA6.gt equivalents and re-scale to 0-1
################################################################################

# Subset only embryos stained with NANOG.rat and GATA6.gt 
# that are not littermates - they get incorporated and processed with
# new-littermates
ng.rat <- unicos$Experiment[which(unicos$CH2 == 'NANOG.rat' & 
                                    unicos$Treatment != 'Littermate')]

# Use tx.channel function to transform NANOG(rat) into NANOG(rb)-equivalents
ablat <- tx.channel(ablat, what.subset = ng.rat, what.model = ng.model, 
                    input.ch = 'CH2', end.ch = 'CH3')

# Re-scale fluorescence values to 0-1 scale

# Create vectors of names for the original and transformed fluorescence values
pre.cols <- colnames(ablat)[grep('ebLogCor$', colnames(ablat))]
post.cols <- paste(pre.cols, 's', sep = '.')
mo.cols <- colnames(ablat)[grep('ebLogCor.x', colnames(ablat))]
pre.cols <- c(pre.cols, mo.cols)
post.cols <- c(post.cols, paste(mo.cols, 's', sep = ''))
rm(mo.cols)

# Create an empty matrix to hold the re-scaled values (.s) for each channel
s.cols <- matrix(0, nrow = length(ablat$CH1.ebLogCor), 
                 ncol = length(post.cols), 
                 dimnames = list(c(), post.cols))
s.cols <- data.frame(s.cols)
# and incorporate into main data frame
ablat <- cbind(ablat, s.cols)
rm(s.cols)

# Create a vector with unique combinations of antibodies and stainings
# and a list with the corresponding experiments stained that way
stains <- unique(paste(unicos$CH2, unicos$CH3, unicos$CH5))
exps <- list()
for(s in 1:length(stains)) { 
  exps[[s]] <- unique(unicos$Experiment[which(paste(unicos$CH2, 
                                                    unicos$CH3, 
                                                    unicos$CH5) == stains[s])])
}

# Cycle through the list of experiments and make the values of each channel 
# relative to the maxima in that group - thus maintaining the relative levels
# between embryos of different litters & stages while eliminating differences
# due to antibody combinations (which are only technical)
for(e in 1:length(exps)) { 
  # Split data in a subset with relevant experiments and another without
  sile <- subset(ablat, Experiment %in% exps[[e]])
  nole <- subset(ablat, !Experiment %in% exps[[e]])
  # Rescale each channel given in pre.cols to the maxima of that channel
  # in the given group (sile) and store the re-scaled value in the
  # corresponding transformed vairable (its cognate in post.col)
  for(c in 1:length(pre.cols)) {
    sile[post.cols[c]] <- sile[pre.cols[c]] / max(sile[pre.cols[c]])
  }
  # Combine both datasets again before next loop
  ablat <<- rbind(sile, nole)
}
rm(sile, nole)

################################################################################
# Write files out to disk for later use
################################################################################

# Extract fixed littermates data and write them out as a separate file
ablat.lms <- subset(ablat, Treatment == 'Littermate')
ablat.lms[which(colnames(ablat.lms) %in% c('target', 'target_t0'))] <- NULL
write.csv(ablat.lms, file = './data/interim/ablat-lms-tx.csv', row.names = F)

# Write all fixed embryos as an interim file and t0 embryos too
write.csv(ablat, file = './data/interim/ablat-fixedall-tx.csv', row.names = F)
write.csv(ablat.t0, file = './data/interim/ablat-t0-tx.csv', row.names = F)

