# This script takes in the raw output generated by esc-xim_read.R
# and performs transformations on the data, namely:
# * correcting for fluorescence decay along the Z-axis

# Check that setup.R has been ran
setup.ran <- exists('looks')
if (setup.ran == F) { 
  source('./src/setup.R')
}
rm(setup.ran)

# Check if data is already loaded and read it in if not
data.exsts <- exists('esc.chimeras')
if(data.exsts == F) { 
  esc.chimeras <- read.csv('./data/raw/esc-xim-raw.csv')
  esc.ref <- read.csv('./references/esc-xim_exp_ref.csv')
}
rm(data.exsts)

# If there is no raw data, run script to generate it
data.exsts <- exists('esc.chimeras')
if(data.exsts == F) { 
  source('./src/data/esc-xim_read.R')
  esc.ref <- read.csv('./references/esc-xim_exp_ref.csv')
}
rm(data.exsts)

# Load functions that will be used in the script
source('./src/functions/eb_cor.R')
source('./src/functions/tx_channels.R')

# Load immunofluorescence reference file and merge with main table
esc.if <- read.csv('./references/esc-xim_if.csv')
esc.chimeras <- merge(esc.chimeras, esc.if)

# Order the levels of factors as desired
esc.chimeras$Treatment <- factor(esc.chimeras$Treatment, 
                                 levels = c('Littermate', 'Control', 'Chimera'))
esc.chimeras$TE_ICM <- factor(esc.chimeras$TE_ICM, levels = c('TE', 'ICM'))

# Rename experiment variable to account for treatments
esc.chimeras$Experiment <- paste(esc.chimeras$Experiment, 
                                 esc.chimeras$Treatment, sep = '.')

# Extract IF information
unicos <- esc.chimeras %>% filter(Channel %in% c('CH2', 'CH3', 'CH5')) %>% 
  group_by(Experiment, Treatment, Genotype1, 
           Genotype2, Channel, Marker) %>% 
  summarize()
unicos <- dcast(unicos, Experiment + Treatment + Genotype1 + Genotype2 ~ 
                  Channel, value.var = 'Marker')

# Write out the unicos table to disk
write.csv(unicos, file = './references/esc-xim_unicos.csv', row.names = F)

# Extract Channel 2 IF information
ch2.marker <- unicos[, c(1:5)]
ch2.marker <- rename(ch2.marker, 'CH2.marker' = 'CH2')
# and incorporate into main table
esc.chimeras <- merge(esc.chimeras, ch2.marker)
rm(ch2.marker)

################################################################################
# Correct for fluorescence decay along the Z-axis
################################################################################

## Correct for Z-associated fluorescence decay for all channels

# Define the possible channels to go through
channels <- c('CH1.Avg', 'CH2.Avg', 'CH3.Avg', 'CH5.Avg')
# Create an empty matrix to hold the corrected values
# with the length of the number of cells in the dataset
ebLogCor <- matrix(0, nrow = length(esc.chimeras$Embryo_ID), 
                   # and as many columns as channels
                   ncol = length(channels),
                   dimnames = list(c(), channels))
# For each channel in 'channels', perform EB correction 
# and store in the corresponding column in 'ebLogCor'
# Critically, use the secondary antibody as grouping variable for ebcor()
# (see annotation in eb_cor.R for details)
for (c in channels) {
  ebLogCor[, c] <- ebcor(esc.chimeras, c, group = esc.chimeras$CH2.marker)
}

# NOTE: this correction method undercorrects the GFP levels for the donor ESCs
# Uncomment below to visualize the effect:
# qplot(Z, CH2.ebLogCor, data = esc.chimeras, color = Identity) + theme_bw() + 
#         facet_wrap( ~ CH2.ab2)

# This issue could be fixed by further grouping by CH2.ab2 AND Identity
# however, this would cause higher fragmentation in the dataset, which I think
# would make the correction less robust. Moreover, the levels of GFP in 
# donor ESCs are irrelevant, as they have been manually classified.

# Convert ebLogCor to data frame and rename columns to CHX.ebLogCor
ebLogCor <- data.frame(ebLogCor)
ebLogCor <- rename(ebLogCor, CH1.ebLogCor = CH1.Avg, 
                   CH2.ebLogCor = CH2.Avg, 
                   CH3.ebLogCor = CH3.Avg,
                   CH5.ebLogCor = CH5.Avg)

# Combine chimeras with the EB corrected values
esc.chimeras <- cbind(esc.chimeras, ebLogCor)
rm(ebLogCor)

################################################################################
# Transform fluorescence values obtained with NANOG.rat and GATA6.rb to
# NANOG.rb and GATA6.gt equivalents and re-scale to 0-1
################################################################################

# Perform a similar transformation as that done for the new-littermates dataset
# to bring values from different staining groups into the same scale

# Select Experiments where NANOG.rat was used or where GATA6.rb was used
ng.rat <- unicos$Experiment[which(unicos$CH2 == 'NANOG.rat')]
g6.rb <- unicos$Experiment[which(unicos$CH3 == 'GATA6.rb')]

# Use tx.channel function to transform NANOG(rat) into NANOG(rb)-equivalents
esc.chimeras <- tx.channel(esc.chimeras, what.subset = ng.rat, 
                           what.model = ng.model, 
                           input.ch = 'CH2', end.ch = 'CH3')
# Use tx.channel function to transform GATA6(rb) into GATA6(gt)-equivalents
esc.chimeras <- tx.channel(esc.chimeras, what.subset = g6.rb, 
                           what.model = gata.model, 
                           input.ch = 'CH3', end.ch = 'CH5')

# Re-scale fluorescence values to 0-1 scale

# Create vectors of names for the original and transformed fluorescence values
pre.cols <- colnames(esc.chimeras)[grep('ebLogCor$', colnames(esc.chimeras))]
post.cols <- paste(pre.cols, 's', sep = '.')
mo.cols <- colnames(esc.chimeras)[grep('ebLogCor.x', colnames(esc.chimeras))]
pre.cols <- c(pre.cols, mo.cols)
post.cols <- c(post.cols, paste(mo.cols, 's', sep = ''))
rm(mo.cols)

# Create an empty matrix to hold the re-scaled values (.s) for each channel
s.cols <- matrix(0, nrow = length(esc.chimeras$CH1.ebLogCor), 
                 ncol = length(post.cols), 
                 dimnames = list(c(), post.cols))
s.cols <- data.frame(s.cols)
# and incorporate into main data frame
esc.chimeras <- cbind(esc.chimeras, s.cols)
rm(s.cols)

# Create a vector with unique combinations of antibodies and stainings
# and a list with the corresponding experiments stained that way
stains <- unique(paste(unicos$CH2, unicos$CH3, unicos$CH5))
exps <- list()
for(s in 1:length(stains)) { 
  exps[[s]] <- unique(unicos$Experiment[which(paste(unicos$CH2, 
                                                    unicos$CH3, 
                                                    unicos$CH5) == stains[s])])
}

# Cycle through the list of experiments and make the values of each channel 
# relative to the maxima in that group - thus maintaining the relative levels
# between embryos of different litters & stages while eliminating differences
# due to antibody combinations (which are only technical)
for(e in 1:length(exps)) { 
  # Split data in a subset with relevant experiments and another without
  sile <- subset(esc.chimeras, Experiment %in% exps[[e]])
  nole <- subset(esc.chimeras, !Experiment %in% exps[[e]])
  # Rescale each channel given in pre.cols to the maxima of that channel
  # in the given group (sile) and store the re-scaled value in the
  # corresponding transformed vairable (its cognate in post.col)
  for(c in 1:length(pre.cols)) {
    sile[post.cols[c]] <- sile[pre.cols[c]] / max(sile[pre.cols[c]])
  }
  # Combine both datasets again before next loop
  esc.chimeras <<- rbind(sile, nole)
}
rm(sile, nole)

################################################################################
# Write data out to interim folder
write.csv(esc.chimeras, file = './data/interim/esc-xim-tx.csv', 
          row.names = F)

# If esc-xim_read.R has not been ran before and data is loaded
# directly from ./data/interim/, generate vector of embryos to 
# exclude from analysis (see ./src/data/esc-xim_read.R for details)
if(exists('small.odd') == F) { 
  small.odd <- unique(subset(esc.chimeras, 
                             Exp_date >= 20180214 & 
                               Exp_date <= 20180222)$Litter)
  }

# Calculate the number of embryos per treatment
n.embryos <- esc.chimeras %>% 
  filter(interaction(Channel, Marker) != 'CH2.no.ab', 
         !Litter %in% small.odd) %>% 
  group_by(Embryo_ID, Treatment, 
           ESC_line, ES_culture, 
           ESC_genotype, Stage.t0, 
           Genotype1, D_cells) %>% 
  summarize() %>% 
  group_by(Treatment, ESC_line, ES_culture, ESC_genotype, 
           Stage.t0, Genotype1, D_cells) %>% 
  summarize(N = n())
n.embryos <- dcast(n.embryos, Treatment + Genotype1 + D_cells ~ 
                     Stage.t0 + ESC_line + ESC_genotype + ES_culture, 
                   value.var = 'N')
n.embryos[is.na(n.embryos)] <- '--'
# and write it out as a .csv file
write.csv(n.embryos, file = './results/esc-xim_N-embryos.csv', row.names = F)

