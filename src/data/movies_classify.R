# This script takes the transformed data generated by movies_tx.R
# identifies events like divisions and cell death and classifies cells
# (all ICM) over time into PrE, epiblast or DP based on 
# expression levels of the reporter Pdgfra:H2B-GFP

# Check that setup.R has been ran
setup.ran <- exists('looks')
if (setup.ran == F) { 
  source('./src/setup.R')
}
rm(setup.ran)

# Source functions that will be used in the script
source('./src/functions/el-classifier.R')

# Check if data is already loaded and read it in if not
if(exists('movies') == F) { 
  movies <- read.csv('./data/interim/movies-all-tx.csv')
}

# If there is no interim data, run scripts to generate it
if(exists('movies') == F) { 
  source('./src/data/movies_read.R')
  source('./src/data/movies_tx.R')
  movies <- read.csv('./data/interim/movies-all-tx.csv')
}

################################################################################
# Assign end point to cells in each track that make it to the end of the movie 
# and capture what the ending is for each cell 
################################################################################

# Calculate the length of each movie (== Embryo) 
# as the max value of the timeframe variable
movies <- split(movies, as.factor(movies$Embryo_ID))
for(e in 1:length(movies)) {
  movies[[e]]$mov.length <- max(movies[[e]]$timeframe)
}
movies <- do.call(rbind, movies)

# Create an empty variable indicating whether or not a cell is an end point
movies$end.point <- F
# Make end point TRUE for cells that exist and are alive at the last time frame
movies$end.point[which(movies$timeframe == movies$mov.length)] <- T

# Split data by Cell_ID (segment of a track between mitosis)
movies <- split(movies, as.factor(movies$Cell_ID))
endings <- list()
# Select the last spot of each track
for(c in 1:length(movies)) { 
  my.sum <- movies[[c]] %>% filter(timeframe == max(timeframe)) %>% 
    group_by(Cell_ID, identity_t0, timeframe, division, 
             death, in.frame, end.point) %>% summarize()
  endings[[c]] <- my.sum
}
movies <- do.call(rbind, movies)
endings <- do.call(rbind, endings)

# Label the end points based on label information gathered earlier
# to indicate wether that cell died, divided, went off frame, was lost, 
# or simply whether that is the last time frame on the movie
endings$ending <- ifelse(endings$death == T, 'death', 
                         ifelse(endings$division == T, 'division', 
                                ifelse(endings$end.point == T, 'end point', 
                                       ifelse(endings$in.frame == F, 'off frame', 
                                              'lost'))))
endings <- endings %>% group_by(Cell_ID, identity_t0, ending) %>% 
  select(Cell_ID, identity_t0, ending)

################################################################################
# Automatically assign identity to cells at t=0 based on Pdgfra levels
################################################################################

# Read in manual thresholds for cell type classification
# These were determined and adjusted manually for each litter, 
# based on the trajectories of the cells in those embryos
my.thres <- read.csv('./references/ablat_man-thres.csv')

# Assign a new variable to movies to store identity over time (identity.t)
movies$identity.t <- 'nada'

# Assign identity at t0 using manual thresholds and make that a variable
# Subset the first time frame for Channel 1
t0 <- subset(movies, Channel == 1 & timeframe == 1)
resto <- subset(movies, timeframe > 1 | 
                  (timeframe == 1 & Channel != 1))

# Classify cells at t=0 for each litter
t0 <- split(t0, as.factor(t0$Litter))
for(l in 1:length(t0)) { 
  # Incorporate manual thresholds for each litter
  th.pre <- my.thres$PRE.thres0[
    which(my.thres$Litter == unique(t0[[l]]$Litter))]
  th.epi <- my.thres$EPI.thres0[
    which(my.thres$Litter == unique(t0[[l]]$Litter))]
  
  # Assign cell types based on threshold and the moving average of Pdgfra
  t0[[l]]$identity.t <- 
    ifelse(t0[[l]]$mavg > th.pre, 'PRE', 
           ifelse(t0[[l]]$mavg < th.epi, 'EPI', 'DP'))
  
  # Incorporate a hard rule where any cell manually scored as EPI or PrE
  # and targeted, will remain so irrespective of the automatic assignment
  was.pre <- t0[[l]]$identity_t0 == 'PRE' & 
    t0[[l]]$cell_treatment == 'targeted'
  t0[[l]]$identity.t[was.pre] <- 'PRE'
  was.epi <- t0[[l]]$identity_t0 == 'EPI' & 
    t0[[l]]$cell_treatment == 'targeted'
  t0[[l]]$identity.t[was.epi] <- 'EPI'
}
t0 <- do.call(rbind, t0)

# Uncomment below to visualize the outcome
# qplot(identity.t, mavg, data = t0, 
#       color = identity_t0, geom = 'jitter') + 
#   looks + facet_wrap( ~ Litter + Stage.t0) + 
#   scale_color_manual(values = idcols) + 
#   theme(aspect.ratio = 1)

# Extract identity @ t=0 calculated automatically above, 
# to assign it as variable to main table
que.id <- t0 %>% group_by(Embryo_ID, TrackID, identity.t) %>% 
  summarize()
que.id <- rename(que.id, identity_t0.th = identity.t)

# Join again t0 and resto to make full movies data frame
movies <- rbind(t0, resto)
movies <- merge(movies, que.id)
rm(t0, resto, que.id)

################################################################################
# Calculate fluorescence intensity thresholds for automatic cell classification
################################################################################

# Calculate the slopes corresponding to the lines between 
# the initial (t = 0) and final (t = end) thresholds I had set

# Incroporate length of movie into thresholds table
movs.len <- movies %>% group_by(Litter) %>% 
  summarize(t.max = max(hours))
my.thres <- merge(my.thres, movs.len)
rm(movs.len)
# Calculate the slope for the PrE and epiblast thresholds
my.thres$p.slope.man <- (my.thres$PRE.thres.end - my.thres$PRE.thres0) / 
  my.thres$t.max
my.thres$e.slope.man <- (my.thres$EPI.thres.end - my.thres$EPI.thres0) / 
  my.thres$t.max

# Fit regression models to PrE and EPI cells in each litter
# to calculate an alternative threshold for each population in the form:
# threshold = manual-threshold + slope.auto * time

# Initialite an empty data frame to store slopes etc
my.cofs <- data.frame(Litter = rep('nada', times = length(movies)), 
                      p.slope.auto = rep(0, times = length(movies)), 
                      e.slope.auto = rep(0, times = length(movies)))

# Split movies into litters
movies <- split(movies, as.factor(movies$Litter))
# Calculate slopes for each litter
for(l in 1:length(movies)) {
  # Extract litter we're working with
  ltr <- unique(movies[[l]]$Litter)
  my.cofs[l, 1] <- ltr
  
  # Fit a linear regression model for Channel 1 for cells
  # classified as PrE at t0 using thresholding
  p.mdl <- lm(mavg ~ hours, 
              data = subset(movies[[l]], 
                            Channel == 1 & 
                              identity_t0.th == 'PRE'))
  # Extract slope and store it in my.cofs
  my.cofs[l, 2] <- coefficients(p.mdl)[2]
  
  # Check if there are EPI cells at t0
  has.epi <- 'EPI' %in% unique(movies[[l]]$identity_t0.th)
  if(has.epi == T) { 
    # if so, fit a linear regression model for Channel 1 for EPI
    e.mdl <- lm(mavg ~ hours, 
                data = subset(movies[[l]], 
                              Channel == 1 & 
                                identity_t0.th == 'EPI'))
    # Extract slope and store it in my.cofs
    my.cofs[l, 3] <- coefficients(e.mdl)[2]
  }
  # otherwise, use the manual slope for epi
  else { 
    e.mdl <- my.thres$e.slope.man[which(my.thres$Litter == ltr)]
    my.cofs[l, 3] <- e.mdl
  }
}

# Combine manual and 'automatic' thresholds
my.thres <- merge(my.thres, my.cofs)

# Merge movies into a data frame again
movies <- do.call(rbind, movies)

# Incorporate manual threshold variable into main movies data frame
movies <- split(movies, as.factor(movies$Litter))
for(l in 1:length(movies)) { 
  # Determine the Litter at hand
  litter <- unique(movies[[l]]$Litter)
  # Define the manual intercept and slope for PrE cells
  p.intx <- my.thres$PRE.thres0[which(my.thres$Litter == litter)]
  p.slope <- my.thres$p.slope.man[which(my.thres$Litter == litter)]
  # and with those, the function defining the threshold over time
  movies[[l]]$pre.th <- p.intx + p.slope * movies[[l]]$hours
  # Define the manual intercept and slope for epiblast cells
  e.intx <- my.thres$EPI.thres0[which(my.thres$Litter == litter)]
  e.slope <- my.thres$e.slope.man[which(my.thres$Litter == litter)]
  # and with those, the function defining the threshold over time
  movies[[l]]$epi.th <- e.intx + e.slope * movies[[l]]$hours
}
movies <- do.call(rbind, movies)

################################################################################
# Automatically assign cell identity over time based on thresholds and Pdgfra
################################################################################

# Make a new variable to register whether there's a fate switch
# defaults to FALSE, but el.classifier() will make it TRUE when there's a switch
movies$switch <- F

# Separate values for channels #1 and other than #1 (Pdgfra levels)
the.one <- subset(movies, Channel == 1)
the.resto <- subset(movies, Channel != 1)

# Create a categorical variable indicating whether the moving average 
# at that point (mavg for t = i) is above the PrE threshold (putative PrE, P), 
# below (putative EPI, E) or in between (DP, D) 
the.one$put.id <- ifelse(the.one$mavg > the.one$pre.th, 'P', 
                         ifelse(the.one$mavg < the.one$epi.th, 'E', 'D'))


# Calculate the difference betwen the mavg and the threshold for each point
the.one$diff.p <- the.one$mavg - the.one$pre.th
the.one$diff.e <- the.one$mavg - the.one$epi.th

# Extract mother cells + daughter branch 1 only
# daughters from branch 2 will be processed below
the.one.a <- subset(the.one, branch %in% c(0, 1))
the.one.a <- split(the.one.a, as.factor(the.one.a$TrackID))

# Run the classifier on mother cells + daughters belonging to branch 1 only
# to determine whether putative PrE and EPI cells are so or not and assign
# cell identity over time.
the.one.a <- el.classifier(the.one.a)

# Create a table with the identity of the mother cells in the.dp.a 
# at the time of mitosis (just before daughter cells begin)
# This will be used to determine the prior identity in daughters belonging
# to branch 2
id.list <- the.one.a
for(i in 1:length(id.list)) {
  id.list[[i]] <- subset(id.list[[i]], genx == 'm')
  id.list[[i]] <- subset(id.list[[i]], 
                         timeframe == max(id.list[[i]]$timeframe))
  id.list[[i]] <- id.list[[i]] %>% 
    group_by(Embryo_ID, TrackID, timeframe, identity.t) %>%
    summarize()
}
id.list <- do.call(rbind, id.list)

# Extract daughter cells belonging to branch 2 only
the.one.b <- subset(the.one, branch == 2)

# Assign to the first time point each daughter cell the same identity
# as the identity of their corresponding mother cell at time of mitosis
# so we can initialize the classifier on them
the.one.b <- split(the.one.b, as.factor(the.one.b$TrackID))
for(i in 1:length(the.one.b)) { 
  id.start <- id.list$identity.t[which(id.list$TrackID == 
                                         unique(the.one.b[[i]]$TrackID))]
  the.one.b[[i]]$identity.t[which(the.one.b[[i]]$timeframe == 
                                    min(the.one.b[[i]]$timeframe))] <- id.start
}

# Run the classifier as above on daughers from branch 2
the.one.b <- el.classifier(the.one.b)

# Assign to granddaughters the same identity as their mother (daughter cells)
# at the time of mitosis, since at this point we do not expect changes

# Extract granddaughters for branches 1 and 2 separately
the.one.c1 <- subset(the.one, branch %in% c(1.1, 1.2))
the.one.c2 <- subset(the.one, branch %in% c(2.1, 2.2))
the.one.c1$identity.t <- NULL
the.one.c2$identity.t <- NULL

# Extract the identity of the daughters of branch 1 at time of division
id.list <- the.one.a
aa <- rep(0, times = length(id.list))
# Extract daughters only and record empty elements in aa (mother-only elements)
for(i in 1:length(id.list)) {
  id.list[[i]] <- subset(id.list[[i]], genx == 'd')
  aa[i] <- length(id.list[[i]]$Embryo_ID)
}
  
# Remove elements of id.list with no data (empty data frames)
id.list <- id.list[- which(aa == 0)]
# Extract identity.t at last time point for each cell
for(i in 1:length(id.list)) {
  id.list[[i]] <- subset(id.list[[i]],
                         timeframe == max(id.list[[i]]$timeframe))
  id.list[[i]] <- id.list[[i]] %>% 
    group_by(Embryo_ID, TrackID, identity.t) %>%
    summarize()
}
id.list <- do.call(rbind, id.list)
# And assign it to their granddaughters (branches 1.1, 1.2)
id.list <- subset(id.list, TrackID %in% unique(the.one.c1$TrackID))
the.one.c1 <- merge(the.one.c1, id.list)

## Extract the identity of the daughters of branch 2 at time of division
id.list <- the.one.b
for(i in 1:length(id.list)) {
  id.list[[i]] <- subset(id.list[[i]], 
                         timeframe == max(id.list[[i]]$timeframe))
  id.list[[i]] <- id.list[[i]] %>% 
    group_by(Embryo_ID, TrackID, identity.t) %>% 
    summarize()
}
id.list <- do.call(rbind, id.list)
# And assign it to their granddaughters (branches 2.1, 2.2)
id.list <- subset(id.list, TrackID %in% unique(the.one.c2$TrackID))
the.one.c2 <- merge(the.one.c2, id.list)

# Turn the mothers and daughters data into data.frames
the.one.a <- do.call(rbind, the.one.a)
the.one.b <- do.call(rbind, the.one.b)

# Combine both sets of granddaughters again
the.one.c <- rbind(the.one.c1, the.one.c2)
rm(the.one.c1, the.one.c2)

# Combine all generations to make the.one again
the.one <- rbind(rbind(the.one.a, the.one.b), the.one.c)
rm(the.one.a, the.one.b, the.one.c)

# Combine Channel 1 and rest into movies again
the.one[which(colnames(the.one) %in% c('put.id', 'diff.p', 'diff.e'))] <- NULL
movies <- rbind(the.one, the.resto)
rm(the.one, the.resto)

################################################################################
# Make factors and order them
################################################################################

movies$identity.t <- factor(movies$identity.t, 
                            levels = c('PRE', 'DP', 'EPI'))
movies$Treatment <- factor(movies$Treatment, 
                           levels = c('Control', 'Ablated', 'Random'))
movies$Stage.t0 <- factor(movies$Stage.t0, 
                          levels = c('[30,50)', '[50,70)', '[70,90)', 
                                     '[90,110)', '[110,130)'))
movies$Cell_diff <- factor(movies$Cell_diff, 
                           levels = c('zero', 'kill_0.25', 'kill_0.5', 
                                      'kill_0.75', 'kill_all'))
movies$identity_t0.th <- factor(movies$identity_t0.th, 
                                levels = levels(movies$identity.t))
movies$target <- factor(movies$target, levels = c('none', 'PRE', 'EPI'))

################################################################################
# Write processed data to file
write.csv(movies, file = './data/processed/movies-all-processed.csv', 
          row.names = F)
write.csv(endings, file = './references/movies-endings.csv', row.names = F)

##