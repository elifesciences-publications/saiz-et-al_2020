# This script takes in the raw output generated by new-lms_read.R
# and the raw littermates file generated by ablat_read.R, combines them
# and performs a series of transformations in the data, namely
# * correcting for fluorescence decay along the Z-axis
# * transforms fluorescence values of NANOG and GATA6 obtained with 
#   multiple antibodies onto an equivalent relative scale

# Check if setup.R has been ran
setup.ran <- exists('looks')
if (setup.ran == F) { 
  source('./src/setup.R')
}
rm(setup.ran)

# Check if data is already loaded 
data.exsts <- exists('new.lms')
if(data.exsts == F) { 
  new.lms <- read.csv('./data/raw/new-lms-raw.csv')
  new.lms.ref <- rbind(read.csv('./references/new-littermates_exp_ref.csv'), 
                       read.csv('./references/fgf4-lms_exp_ref.csv'))
}
rm(data.exsts)

# Load functions that will be used in the script
source('./src/functions/eb_cor.R')
source('./src/functions/tx_channels.R')

# Remove wt embryos used for antibody test, negative controls
# and embryos of unknown genotype
new.lms <- subset(new.lms, Treatment == 'Littermate' & 
                    Genotype1 != 'unknown')

# Load immunofluorescence reference files
new.lms.if <- read.csv('./references/new-littermates_if.csv')
f4.lms.if <- read.csv('./references/fgf4-lms_if.csv')

# Extract info for Channels 2 and their associated marker (primary ab) 
# and secondary antibody (ab.2)
newlms.ch2 <- new.lms.if %>% 
  filter(Channel == 'CH2') %>%
  group_by(Experiment, Litter, Genotype1, Channel, Marker) %>%
  summarize()
f4.lms.ch2 <- f4.lms.if %>% 
  filter(Channel == 'CH2') %>%
  group_by(Experiment, Litter, Channel, Marker) %>%
  summarize()

## Cast both to wide format
newlms.ch2 <- dcast(newlms.ch2, Experiment + Genotype1 ~ Channel, 
                    value.var = 'Marker')
newlms.ch2 <- rename(newlms.ch2, CH2.marker = CH2)

f4.lms.ch2 <- dcast(f4.lms.ch2, Experiment ~ Channel, value.var = 'Marker')
f4.lms.ch2 <- rename(f4.lms.ch2, CH2.marker = CH2)

# Split new.lms into Fgf4 subet and rest, to incorporate IF information
# without losing data, as Fgf4 if file doesn't account for Genotype
aa <- subset(new.lms, Gene1 != 'Fgf4')
bb <- subset(new.lms, Gene1 == 'Fgf4')

# Incorporate IF data into main tables
aa <- merge(aa, new.lms.if)
aa <- merge(aa, newlms.ch2)
bb <- merge(bb, f4.lms.if)
bb <- merge(bb, f4.lms.ch2)

# Bind again aa and bb into new.lms and clean up
new.lms <- rbind.fill(aa, bb)
rm(newlms.ch2, f4.lms.ch2, aa, bb)

## Merge IF tables, as they will be used later
new.lms.if <- merge(new.lms.if, f4.lms.if)

# Modify Experiment variable to account for different genotypes
new.lms$Experiment <- paste(new.lms$Experiment, new.lms$Genotype1, sep = '.')
new.lms.if$Experiment <- paste(new.lms.if$Experiment, 
                               new.lms.if$Genotype1, sep = '.')

################################################################################
## Correct for fluorescence decay along the Z-axis
################################################################################

# Since eb.cor() is designed to correct one channel (variable) at a time
# we need to loop it through the fluorescence channels we want to correct

# Define the possible channels to go through
channels <- c('CH1.Avg', 'CH2.Avg', 'CH3.Avg', 'CH5.Avg')

# Create an empty matrix to hold the corrected values
# with the length of the number of cells in the dataset
ebLogCor <- matrix(0, nrow = length(new.lms$Embryo_ID), 
                   # and as many columns as channels
                   ncol = length(channels),
                   dimnames = list(c(), channels))

# For each channel in 'channels', perform Empirical Bayes correction 
# and store in the corresponding column in 'ebLogCor'
# Critically, use the marker for CH2 as grouping variable for ebcor()
# (see annotation in eb_cor.R for details)
for (c in channels) {
  ebLogCor[, c] <- ebcor(new.lms, c, group = new.lms$CH2.marker)
}
# Convert ebLogCor to data frame and rename columns to CHX.ebLogCor
ebLogCor <- data.frame(ebLogCor)
ebLogCor <- rename(ebLogCor, CH1.ebLogCor = CH1.Avg, 
                   CH2.ebLogCor = CH2.Avg, 
                   CH3.ebLogCor = CH3.Avg,
                   CH5.ebLogCor = CH5.Avg)

# Incorporate ebLogCor values into main table
new.lms <- cbind(new.lms, ebLogCor)
rm(ebLogCor)

################################################################################
## Incorporate littermate data from ablations experiments
################################################################################

# Read in reference littermates from the ablation dataset
# In these, values have been corrected for fluorescence decay along Z
# but are otherwise untransformed and have no identity assigned
ablat.lms <- read.csv('./data/interim/ablat-lms-tx.csv')

# Rename the variable group.median to litter.median
ablat.lms <- rename(ablat.lms, litter.median = group.median)

# Select variables on each data set that are contained in the other
# WARNING: I have verified this step doesn't drop any critical variable
# in these dataset, do not apply directly to other data without checking first
ablat.lms <- ablat.lms[colnames(ablat.lms)[
  which(colnames(ablat.lms) %in% colnames(new.lms))]]
new.lms <- new.lms[colnames(new.lms)[
  which(colnames(new.lms) %in% colnames(ablat.lms))]]

# Combine both datasets
new.lms <- rbind(new.lms, ablat.lms)
new.lms <- stage(new.lms)

################################################################################
## Transform fluorescence values obtained with NANOG.rat and GATA6.rb to
## NANOG.rb and GATA6.gt equivalents and re-scale to 0-1
################################################################################

# Generate data frame containing the unique values 
# for the markers associated with channels 2, 3 and 5 in the new-lms dataset
unicos <- new.lms %>% filter(Channel %in% c('CH2', 'CH3', 'CH5')) %>% 
  group_by(Experiment, Treatment, Genotype1, Channel, Marker) %>% 
  summarize()
unicos <- dcast(unicos, Experiment + Treatment + Genotype1 ~ 
                  Channel, value.var = 'Marker')

# Write out the unicos table to disk
write.csv(unicos, file = './references/new-lms_unicos.csv', row.names = F)

# Select Experiments where NANOG.rat was used or where GATA6.rb was used
ng.rat <- unicos$Experiment[which(unicos$CH2 == 'NANOG.rat')]
g6.rb <- unicos$Experiment[which(unicos$CH3 == 'GATA6.rb')]
# g4.rb <- unicos$Experiment[which(unicos$CH3 == 'GATA4.rb')]
# s17.gt <- unicos$Experiment[which(unicos$CH5 == 'SOX17.gt')]
# g6.gt <- unicos$Experiment[which(unicos$CH5 == 'GATA6.gt')]
# gfp <- unicos$Experiment[which(unicos$CH2 == 'GFP' & unicos$Genotype1 == 'het')]

# Use tx.channel function to transform NANOG(rat) into NANOG(rb)-equivalents
new.lms <- tx.channel(new.lms, what.subset = ng.rat, what.model = ng.model, 
                      input.ch = 'CH2', end.ch = 'CH3')
# Use tx.channel function to transform GATA6(rb) into GATA6(gt)-equivalents
new.lms <- tx.channel(new.lms, what.subset = g6.rb, what.model = gata.model, 
                      input.ch = 'CH3', end.ch = 'CH5')

# Create vectors of names for the original and transformed fluorescence values
pre.cols <- colnames(new.lms)[grep('ebLogCor$', colnames(new.lms))]
post.cols <- paste(pre.cols, 's', sep = '.')
mo.cols <- colnames(new.lms)[grep('ebLogCor.x', colnames(new.lms))]
pre.cols <- c(pre.cols, mo.cols)
post.cols <- c(post.cols, paste(mo.cols, 's', sep = ''))
rm(mo.cols)

# Create an empty matrix to hold the re-scaled values (.s) for each channel
s.cols <- matrix(0, nrow = length(new.lms$CH1.ebLogCor), 
                   ncol = length(post.cols), 
                   dimnames = list(c(), post.cols))
s.cols <- data.frame(s.cols)
# and incorporate into main data frame
new.lms <- cbind(new.lms, s.cols)
rm(s.cols)

# Create a vector with unique combinations of antibodies and stainings
# and a list with the corresponding experiments stained that way
stains <- unique(paste(unicos$CH2, unicos$CH3, unicos$CH5))
exps <- list()
for(s in 1:length(stains)) { 
  exps[[s]] <- unique(unicos$Experiment[which(paste(unicos$CH2, 
                                                    unicos$CH3, 
                                                    unicos$CH5) == stains[s])])
}

# Cycle through the list of experiments and make the values of each channel 
# relative to the maxima in that group - thus maintaining the relative levels
# between embryos of different litters & stages while eliminating differences
# due to antibody combinations (which are only technical)
for(e in 1:length(exps)) { 
  # Split data in a subset with relevant experiments and another without
  sile <- subset(new.lms, Experiment %in% exps[[e]])
  nole <- subset(new.lms, !Experiment %in% exps[[e]])
  # Rescale each channel given in pre.cols to the maxima of that channel
  # in the given group (sile) and store the re-scaled value in the
  # corresponding transformed vairable (its cognate in post.col)
  for(c in 1:length(pre.cols)) {
    sile[post.cols[c]] <- sile[pre.cols[c]] / max(sile[pre.cols[c]])
  }
  # Combine both datasets again before next loop
  new.lms <<- rbind(sile, nole)
}
rm(sile, nole)

################################################################################
# Order factors
################################################################################

new.lms$TE_ICM <- factor(new.lms$TE_ICM, levels = c('TE', 'ICM'))
new.lms$Genotype1 <- factor(new.lms$Genotype1, 
                            levels = c('wt', 'wt/fl', 'het', 'fl/ko', 
                                       'ko', 'tbd'))

################################################################################
# Write this transformed dataset out to the ./data/interim folder
write.csv(new.lms, file = './data/interim/new-lms-tx.csv', row.names = F)

