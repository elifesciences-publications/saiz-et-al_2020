# This script performs some basic transformations
# on the movie data generated by movies_read.R
# and transforms Pdgfra:H2B-GFP levels to make them relative
# and to calculate moving averages

# Check that setup.R has been ran
setup.ran <- exists('looks')
if (setup.ran == F) { 
  source('./src/setup.R')
}
rm(setup.ran)

# Load some extra packages
library('zoo')
library('tidyquant')

# Source functions that will be used in the script
source('./src/functions/eb_cor.R')
# source('./src/functions/el-classifier.R')

# Check if data is already loaded and read it in if not
if(exists('movies') == F) { 
  movies <- read.csv('./data/raw/movies-all.csv')
  }

# Convert time frames into minutes (each time interval is 15 minutes)
movies$minutes <- (movies$timeframe - 1) * 15
# and hours
movies$hours <- movies$minutes / 60

# Transform X, Y, Z scales to make them relative, as they seem to be 
# on totally different scales (likely an artifact of Imaris processing)
zz <- movies %>% group_by(Embryo_ID) %>% 
  summarize(Zmin = min(Z), 
            Xmin = min(X), 
            Ymin = min(Y))
movies <- merge(movies, zz)
movies$Z <- movies$Z - movies$Zmin 
movies$X <- movies$X - movies$Xmin
movies$Y <- movies$Y - movies$Ymin 
movies$Zmin <- NULL
movies$Xmin <- NULL
movies$Ymin <- NULL
rm(zz)

################################################################################
# Correct fluorescence decay along the Z axis for each channel
# CH1 always correspond to Pdgfra:H2B-GFP
# CH2 corresponds to mKate2 in embryos where Genotype1 == mKate/+ or
# mKate/mKate. In wt embryos, CH2 is the bright field
################################################################################

# Split into list to correct each channel
movies <- split(movies, as.factor(movies$Channel))
for(c in 1:length(movies)) { 
  movies[[c]]$mean.ebLogCor <- ebcor(movies[[c]], channel = 'Mean')
}
movies <- do.call(rbind, movies)

################################################################################
# Calculate relative fluorescence values for CH1 (Pdgfra:H2B-GFP)
################################################################################

# Calculate CH1 mean (corrected) relative to the maxima in that litter 
# to compare different experiments

m1 <- subset(movies, Channel == 1)
m2 <- subset(movies, Channel != 1)

m1 <- split(m1, as.factor(m1$Litter))
for(l in 1:length(m1)) { 
  m1[[l]]$mean.ebLogCor.rel <- 
    m1[[l]]$mean.ebLogCor/max(m1[[l]]$mean.ebLogCor)
}
m1 <- do.call(rbind, m1)

# Calculate CH1 mean (corrected) relative to its initial value 
# for each track (fold change)

m1 <- split(m1, as.factor(m1$TrackID))
for(t in 1:length(m1)) { 
  m1[[t]]$mean.ebLogCor.fc <- 
    m1[[t]]$mean.ebLogCor - m1[[t]]$mean.ebLogCor[
      which(m1[[t]]$timeframe == 1)]
}
m1 <- do.call(rbind, m1)

# Calculate moving average of Pdgfra expression for each cell 
# (= track segments between divisions) with a window of 4 time frames (1h) 

# Split the file by Cell_ID
m1 <- split(m1, as.factor(m1$Cell_ID))

# Set the width of the moving window
k <- 4

# Loop through the list to calculate the moving average per Cell_ID
# for both the absolute, relative and fold-change mean level of CH1
for(c in 1:length(m1)){ 
  # Check the length of the given Cell
  my.check <- length(m1[[c]]$Embryo_ID) < k+1
  # If smaller than the window given (k), do not transform, 
  # and make the fold-change (fc) value, the same as the original
  if(my.check == T) {
    m1[[c]]$mavg <- m1[[c]]$mean.ebLogCor
    m1[[c]]$mavg.rel <- m1[[c]]$mean.ebLogCor.rel
    m1[[c]]$mavg.fc <- m1[[c]]$mean.ebLogCor.fc
  }
  # If bigger than the window given (k), use the zoo package
  # to calculate the moving averages
  else { 
    # Create zoo objects reordering intensities by timeframe 
    # (absolulte, relative and fold change)
    my.zoo <- zoo(x = m1[[c]]$mean.ebLogCor, 
                  order.by = m1[[c]]$timeframe)
    mo.zoo <- zoo(x = m1[[c]]$mean.ebLogCor.rel, 
                  order.by = m1[[c]]$timeframe)
    momo.zoo <- zoo(x = m1[[c]]$mean.ebLogCor.fc, 
                    order.by = m1[[c]]$timeframe)
    # Calculate rollmean for each zoo object, with the given k
    # and extending values to fill in gaps, towards the left
    # (fill gap with the next value to the right)
    mavg <- rollmean(my.zoo, k = k, fill = 'extend', align = 'left')
    mavg.rel <- rollmean(mo.zoo, k = k, fill = 'extend', align = 'left')
    mavg.fc <- rollmean(momo.zoo, k = k, fill = 'extend', align = 'left')
    # Combine moving averages with timeframe and combine with original table
    timeframe <- m1[[c]]$timeframe[order(m1[[c]]$timeframe)]
    mavg <- data.frame(mavg, timeframe)
    mavg.rel <- data.frame(mavg.rel, timeframe)
    mavg.fc <- data.frame(mavg.fc, timeframe)
    m1[[c]] <- merge(m1[[c]], mavg)
    m1[[c]] <- merge(m1[[c]], mavg.rel)
    m1[[c]] <- merge(m1[[c]], mavg.fc)
  }
}
m1 <- do.call(rbind, m1)

movies <- rbind.fill(m1, m2)
rm(m1, m2)

################################################################################
# Write table out to file
write.csv(movies, file = './data/interim/movies-all-tx.csv', row.names = F)

